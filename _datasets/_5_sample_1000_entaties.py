"""Generated by GPT-5.1, reviewed and modified by Shiling Deng, 26/11/2025"""
import os
import json
import random
from collections import defaultdict

import numpy as np
import matplotlib.pyplot as plt

DATA_DIR = "filtered_data"

IMDB_FILE = os.path.join(DATA_DIR, "stanfordnlp_imdb_train_samples_length_interval_1.json")
SMS_FILE = os.path.join(DATA_DIR, "ucirvine_sms_spam_train_samples_length_interval_1.json")
OUT_FILE = os.path.join(DATA_DIR, "imdb_sms_interval_1_pairs.json")
FIG_FILE = os.path.join(DATA_DIR, "imdb_sms_interval_1_pair_distribution.png")


def load_json(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def sample_by_label(examples, label_key="label", n_per_label=500):
    """
    examples: list[dict] with a 'label' key
    returns: dict[label] -> list[examples], each list has length n_per_label
    """
    by_label = defaultdict(list)
    for ex in examples:
        by_label[ex[label_key]].append(ex)

    sampled = {}
    for label, exs in by_label.items():
        if len(exs) < n_per_label:
            raise ValueError(
                f"Not enough examples for label {label}: "
                f"needed {n_per_label}, found {len(exs)}"
            )
        sampled[label] = random.sample(exs, n_per_label)
    return sampled

def plot_pair_distribution(pairs, fig_path):
    """
    pairs: list of dicts with keys 'imdb_label' and 'sms_label' (0 or 1)
    Plots a 2x2 confusion-matrix-like figure of pair counts.
    """
    # 2x2 matrix: rows = IMDB label (0,1), cols = SMS label (0,1)
    cm = np.zeros((2, 2), dtype=int)
    for p in pairs:
        imdb_label = int(p["label_context_1"])
        sms_label = int(p["label_context_2"])
        cm[imdb_label, sms_label] += 1

    fig, ax = plt.subplots()
    im = ax.imshow(cm)

    # Set axis ticks and labels
    ax.set_xticks([0, 1])
    ax.set_yticks([0, 1])
    ax.set_xticklabels(["SMS 0", "SMS 1"])
    ax.set_yticklabels(["IMDB 0", "IMDB 1"])

    ax.set_xlabel("SMS label")
    ax.set_ylabel("IMDB label")
    ax.set_title("Distribution of IMDBâ€“SMS label pairs")

    # Annotate each cell with the count
    for i in range(2):
        for j in range(2):
            ax.text(
                j,
                i,
                str(cm[i, j]),
                ha="center",
                va="center"
            )

    fig.colorbar(im, ax=ax)
    plt.tight_layout()
    plt.savefig(fig_path, dpi=300)
    plt.close(fig)
    print(f"Saved pair distribution figure to: {fig_path}")


def main():
    random.seed(45)  # for reproducibility

    # 1. Load the two JSON files
    imdb_examples = load_json(IMDB_FILE)
    sms_examples = load_json(SMS_FILE)

    # 2. Sample 500 examples from each label (0 and 1) for each dataset
    imdb_sampled_by_label = sample_by_label(imdb_examples, label_key="label", n_per_label=500)
    sms_sampled_by_label = sample_by_label(sms_examples, label_key="label", n_per_label=500)

    # Flatten to get 1000 examples per dataset
    imdb_selected = imdb_sampled_by_label[0] + imdb_sampled_by_label[1]
    sms_selected = sms_sampled_by_label[0] + sms_sampled_by_label[1]

    # Shuffle them independently
    random.shuffle(imdb_selected)
    random.shuffle(sms_selected)

    # 3. Randomly combine the 1000 imdb items and 1000 sms items to form 1000 pairs
    num_pairs = 1000
    pairs = []

    for i in range(num_pairs):
        imdb_ex = imdb_selected[i]
        sms_ex = sms_selected[i]

        pair = {
            "context_1": imdb_ex["text"],   # IMDB text
            "context_2": sms_ex["sms"],     # SMS text
            "label_context_1": imdb_ex["label"],
            "label_context_2": sms_ex["label"],
        }
        pairs.append(pair)

    # 4. Save the pairs to JSON
    os.makedirs(DATA_DIR, exist_ok=True)
    with open(OUT_FILE, "w", encoding="utf-8") as f:
        json.dump(pairs, f, ensure_ascii=False, indent=2)

    print(f"Saved {len(pairs)} pairs to: {OUT_FILE}")

    # 5. Plot confusion-matrix-like distribution of label combinations
    plot_pair_distribution(pairs, FIG_FILE)


if __name__ == "__main__":
    main()
